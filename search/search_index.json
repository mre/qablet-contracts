{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is Qablet? A Qablet timetable defines a financial product using a sequence of payments, choices and conditions. A valuation model implemented with a Qablet parser can value any contract, as long as the contract can be described using a Qablet Timetable. Overview of Documentation The SPECIFICATIONS section describes the various elements of the language. Start with the timetable . The EXAMPLES section has code samples to create many common financial contracts such as bonds, options, swaps, and swaptions. Start with the Introduction . Note : This repositary contains code to create qablet timetables. It does not contain models that price qablet timetables. Such models will be available in other independent projects.","title":"Home"},{"location":"#what-is-qablet","text":"A Qablet timetable defines a financial product using a sequence of payments, choices and conditions. A valuation model implemented with a Qablet parser can value any contract, as long as the contract can be described using a Qablet Timetable.","title":"What is Qablet?"},{"location":"#overview-of-documentation","text":"The SPECIFICATIONS section describes the various elements of the language. Start with the timetable . The EXAMPLES section has code samples to create many common financial contracts such as bonds, options, swaps, and swaptions. Start with the Introduction . Note : This repositary contains code to create qablet timetables. It does not contain models that price qablet timetables. Such models will be available in other independent projects.","title":"Overview of Documentation"},{"location":"examples/bond/","text":"Bonds This module contains examples of creating timetables for Zero Coupon Bond and related contracts. zbp_timetable(ccy, opt_maturity, bond_maturity, strike, track='') Create timetable for a zero coupon bond put. Parameters: ccy ( str ) \u2013 the currency of the bond. opt_maturity ( float ) \u2013 the maturity of the option in years. bond_maturity ( float ) \u2013 the maturity of the option in years. strike ( float ) \u2013 the option strike. track ( str , default: '' ) \u2013 an optional identifier for the contract. Source code in qablet_contracts\\bond\\zero.py def zbp_timetable( ccy: str, opt_maturity: float, bond_maturity: float, strike: float, track: str = \"\", ) -> dict: \"\"\"Create timetable for a zero coupon bond put. Args: ccy: the currency of the bond. opt_maturity: the maturity of the option in years. bond_maturity: the maturity of the option in years. strike: the option strike. track: an optional identifier for the contract. \"\"\" events = [ { \"track\": track, \"time\": opt_maturity, \"op\": \">\", \"quantity\": 0, \"unit\": ccy, }, # Choose greater of nothing (get 0) or exercise (continue to remaining events) { \"track\": track, \"time\": opt_maturity, \"op\": \"+\", \"quantity\": strike, \"unit\": ccy, }, # get strike at expiration { \"track\": track, \"time\": bond_maturity, \"op\": \"+\", \"quantity\": -1, \"unit\": ccy, }, # pay bond notional at bond expiration ] return timetable_from_dicts(events) zcb_timetable(ccy, maturity, track='') Create timetable for a zero coupon bond. Parameters: ccy ( str ) \u2013 the currency of the bond. maturity ( float ) \u2013 the maturity of the bond in years. track ( str , default: '' ) \u2013 an optional identifier for the contract. Source code in qablet_contracts\\bond\\zero.py def zcb_timetable(ccy: str, maturity: float, track: str = \"\") -> dict: \"\"\"Create timetable for a zero coupon bond. Args: ccy: the currency of the bond. maturity: the maturity of the bond in years. track: an optional identifier for the contract. \"\"\" events = [ { \"track\": track, \"time\": maturity, \"op\": \"+\", \"quantity\": 1, \"unit\": ccy, } # get bond notional at bond expiration ] return timetable_from_dicts(events)","title":"Bonds"},{"location":"examples/bond/#bonds","text":"This module contains examples of creating timetables for Zero Coupon Bond and related contracts.","title":"Bonds"},{"location":"examples/bond/#qablet_contracts.bond.zero.zbp_timetable","text":"Create timetable for a zero coupon bond put. Parameters: ccy ( str ) \u2013 the currency of the bond. opt_maturity ( float ) \u2013 the maturity of the option in years. bond_maturity ( float ) \u2013 the maturity of the option in years. strike ( float ) \u2013 the option strike. track ( str , default: '' ) \u2013 an optional identifier for the contract. Source code in qablet_contracts\\bond\\zero.py def zbp_timetable( ccy: str, opt_maturity: float, bond_maturity: float, strike: float, track: str = \"\", ) -> dict: \"\"\"Create timetable for a zero coupon bond put. Args: ccy: the currency of the bond. opt_maturity: the maturity of the option in years. bond_maturity: the maturity of the option in years. strike: the option strike. track: an optional identifier for the contract. \"\"\" events = [ { \"track\": track, \"time\": opt_maturity, \"op\": \">\", \"quantity\": 0, \"unit\": ccy, }, # Choose greater of nothing (get 0) or exercise (continue to remaining events) { \"track\": track, \"time\": opt_maturity, \"op\": \"+\", \"quantity\": strike, \"unit\": ccy, }, # get strike at expiration { \"track\": track, \"time\": bond_maturity, \"op\": \"+\", \"quantity\": -1, \"unit\": ccy, }, # pay bond notional at bond expiration ] return timetable_from_dicts(events)","title":"zbp_timetable()"},{"location":"examples/bond/#qablet_contracts.bond.zero.zcb_timetable","text":"Create timetable for a zero coupon bond. Parameters: ccy ( str ) \u2013 the currency of the bond. maturity ( float ) \u2013 the maturity of the bond in years. track ( str , default: '' ) \u2013 an optional identifier for the contract. Source code in qablet_contracts\\bond\\zero.py def zcb_timetable(ccy: str, maturity: float, track: str = \"\") -> dict: \"\"\"Create timetable for a zero coupon bond. Args: ccy: the currency of the bond. maturity: the maturity of the bond in years. track: an optional identifier for the contract. \"\"\" events = [ { \"track\": track, \"time\": maturity, \"op\": \"+\", \"quantity\": 1, \"unit\": ccy, } # get bond notional at bond expiration ] return timetable_from_dicts(events)","title":"zcb_timetable()"},{"location":"examples/equity/","text":"Equities This module contains examples of creating timetables for equity vanilla and exotic contracts. Utils for creating vanilla options timetable option_timetable(ccy, asset_name, strike, maturity, is_call, track='') Create timetable for an equity vanilla call option. Parameters: ccy ( str ) \u2013 the currency of the option. asset_name ( str ) \u2013 the name of the underlying asset. strike ( float ) \u2013 the option strike. maturity ( float ) \u2013 the maturity of the option in years. is_call ( bool ) \u2013 true if the option is a call. track ( str , default: '' ) \u2013 an optional identifier for the contract. Source code in qablet_contracts\\equity\\vanilla.py def option_timetable( ccy: str, asset_name: str, strike: float, maturity: float, is_call: bool, track: str = \"\", ) -> dict: \"\"\"Create timetable for an equity vanilla call option. Args: ccy: the currency of the option. asset_name: the name of the underlying asset. strike: the option strike. maturity: the maturity of the option in years. is_call: true if the option is a call. track: an optional identifier for the contract. \"\"\" events = [ { \"track\": track, \"time\": maturity, \"op\": \">\", \"quantity\": 0, \"unit\": ccy, }, { \"track\": track, \"time\": maturity, \"op\": \"+\", \"quantity\": -strike, \"unit\": ccy, }, { \"track\": track, \"time\": maturity, \"op\": \"+\", \"quantity\": 1, \"unit\": asset_name, }, ] return timetable_from_dicts(events) Utils for creating cliquet contracts. clique_timetable(ccy, asset_name, fixings, global_floor, local_floor, local_cap, track='') Create timetable for an accumulator cliquet. Parameters: ccy ( str ) \u2013 the currency of the bond. asset_name ( str ) \u2013 the name of the underlying asset. fixings ( list [ float ] ) \u2013 the fixing times of the cliquet. global_floor ( float ) \u2013 the global floor of the cliquet. local_floor ( float ) \u2013 the local floor of the cliquet. local_cap ( float ) \u2013 the local cap of the cliquet. track ( str , default: '' ) \u2013 an optional identifier for the contract. Source code in qablet_contracts\\equity\\cliquet.py def clique_timetable( ccy: str, asset_name: str, fixings: list[float], global_floor: float, local_floor: float, local_cap: float, track: str = \"\", ) -> dict: \"\"\"Create timetable for an accumulator cliquet. Args: ccy: the currency of the bond. asset_name: the name of the underlying asset. fixings: the fixing times of the cliquet. global_floor: the global floor of the cliquet. local_floor: the local floor of the cliquet. local_cap: the local cap of the cliquet. track: an optional identifier for the contract. \"\"\" maturity = fixings[-1] # define timetable events = [ { \"track\": None, \"time\": fixings[0], \"op\": \"s\", \"quantity\": 0, \"unit\": \"_INIT\", # initialize accumulator } ] for fixing_time in fixings[1:]: events.append( { \"track\": None, \"time\": fixing_time, \"op\": \"s\", \"quantity\": 0, \"unit\": \"_UPDATE\", # update accumulator } ) events.append( { \"track\": track, \"time\": maturity, \"op\": \">\", # global floor \"quantity\": global_floor, \"unit\": ccy, } ) events.append( { \"track\": track, \"time\": maturity, \"op\": \"+\", # pay the accumulated amount \"quantity\": 1, \"unit\": \"_A\", } ) # define accumulator functions def accumulator_init_fn(inputs): [s] = inputs return [0, s] # [A, S_last] def accumulator_update_fn(inputs): [s, s_last, a] = inputs ret = s / s_last - 1.0 # ret = S / S_last - 1 ret = np.maximum(local_floor, ret) ret = np.minimum(local_cap, ret) return [a + ret, s] # [A, S_last] return { \"events\": pa.RecordBatch.from_pylist(events, schema=EVENT_SCHEMA), \"expressions\": { \"_INIT\": { \"type\": \"snapper\", \"inp\": [asset_name], \"snap_fn\": accumulator_init_fn, \"out\": [\"_A\", \"_S_last\"], }, \"_UPDATE\": { \"type\": \"snapper\", \"inp\": [asset_name, \"_S_last\", \"_A\"], \"snap_fn\": accumulator_update_fn, \"out\": [\"_A\", \"_S_last\"], }, }, }","title":"Equities"},{"location":"examples/equity/#equities","text":"This module contains examples of creating timetables for equity vanilla and exotic contracts. Utils for creating vanilla options timetable","title":"Equities"},{"location":"examples/equity/#qablet_contracts.equity.vanilla.option_timetable","text":"Create timetable for an equity vanilla call option. Parameters: ccy ( str ) \u2013 the currency of the option. asset_name ( str ) \u2013 the name of the underlying asset. strike ( float ) \u2013 the option strike. maturity ( float ) \u2013 the maturity of the option in years. is_call ( bool ) \u2013 true if the option is a call. track ( str , default: '' ) \u2013 an optional identifier for the contract. Source code in qablet_contracts\\equity\\vanilla.py def option_timetable( ccy: str, asset_name: str, strike: float, maturity: float, is_call: bool, track: str = \"\", ) -> dict: \"\"\"Create timetable for an equity vanilla call option. Args: ccy: the currency of the option. asset_name: the name of the underlying asset. strike: the option strike. maturity: the maturity of the option in years. is_call: true if the option is a call. track: an optional identifier for the contract. \"\"\" events = [ { \"track\": track, \"time\": maturity, \"op\": \">\", \"quantity\": 0, \"unit\": ccy, }, { \"track\": track, \"time\": maturity, \"op\": \"+\", \"quantity\": -strike, \"unit\": ccy, }, { \"track\": track, \"time\": maturity, \"op\": \"+\", \"quantity\": 1, \"unit\": asset_name, }, ] return timetable_from_dicts(events) Utils for creating cliquet contracts.","title":"option_timetable()"},{"location":"examples/equity/#qablet_contracts.equity.cliquet.clique_timetable","text":"Create timetable for an accumulator cliquet. Parameters: ccy ( str ) \u2013 the currency of the bond. asset_name ( str ) \u2013 the name of the underlying asset. fixings ( list [ float ] ) \u2013 the fixing times of the cliquet. global_floor ( float ) \u2013 the global floor of the cliquet. local_floor ( float ) \u2013 the local floor of the cliquet. local_cap ( float ) \u2013 the local cap of the cliquet. track ( str , default: '' ) \u2013 an optional identifier for the contract. Source code in qablet_contracts\\equity\\cliquet.py def clique_timetable( ccy: str, asset_name: str, fixings: list[float], global_floor: float, local_floor: float, local_cap: float, track: str = \"\", ) -> dict: \"\"\"Create timetable for an accumulator cliquet. Args: ccy: the currency of the bond. asset_name: the name of the underlying asset. fixings: the fixing times of the cliquet. global_floor: the global floor of the cliquet. local_floor: the local floor of the cliquet. local_cap: the local cap of the cliquet. track: an optional identifier for the contract. \"\"\" maturity = fixings[-1] # define timetable events = [ { \"track\": None, \"time\": fixings[0], \"op\": \"s\", \"quantity\": 0, \"unit\": \"_INIT\", # initialize accumulator } ] for fixing_time in fixings[1:]: events.append( { \"track\": None, \"time\": fixing_time, \"op\": \"s\", \"quantity\": 0, \"unit\": \"_UPDATE\", # update accumulator } ) events.append( { \"track\": track, \"time\": maturity, \"op\": \">\", # global floor \"quantity\": global_floor, \"unit\": ccy, } ) events.append( { \"track\": track, \"time\": maturity, \"op\": \"+\", # pay the accumulated amount \"quantity\": 1, \"unit\": \"_A\", } ) # define accumulator functions def accumulator_init_fn(inputs): [s] = inputs return [0, s] # [A, S_last] def accumulator_update_fn(inputs): [s, s_last, a] = inputs ret = s / s_last - 1.0 # ret = S / S_last - 1 ret = np.maximum(local_floor, ret) ret = np.minimum(local_cap, ret) return [a + ret, s] # [A, S_last] return { \"events\": pa.RecordBatch.from_pylist(events, schema=EVENT_SCHEMA), \"expressions\": { \"_INIT\": { \"type\": \"snapper\", \"inp\": [asset_name], \"snap_fn\": accumulator_init_fn, \"out\": [\"_A\", \"_S_last\"], }, \"_UPDATE\": { \"type\": \"snapper\", \"inp\": [asset_name, \"_S_last\", \"_A\"], \"snap_fn\": accumulator_update_fn, \"out\": [\"_A\", \"_S_last\"], }, }, }","title":"clique_timetable()"},{"location":"examples/rate/","text":"Rates This module contains examples of creating timetables for rate contracts such as swaps and swaptions. bermuda_swaption_timetable(ccy, times, strike_rate, track='') Create timetable for a co-terminal bermuda swaption. Parameters: ccy ( str ) \u2013 the currency of the swap. times ( list [ float ] ) \u2013 the period times of the underlying swap, including the inception and maturity. strike_rate ( float ) \u2013 the strike rate of the swaption (in units, i.e. 0.02 means 200 bps). track ( str , default: '' ) \u2013 an optional identifier for the contract. Source code in qablet_contracts\\rate\\swaption.py def bermuda_swaption_timetable( ccy: str, times: list[float], strike_rate: float, track: str = \"\" ) -> dict: \"\"\"Create timetable for a co-terminal bermuda swaption. Args: ccy: the currency of the swap. times: the period times of the underlying swap, including the inception and maturity. strike_rate: the strike rate of the swaption (in units, i.e. 0.02 means 200 bps). track: an optional identifier for the contract. \"\"\" events = [] for start, end in zip(times[0:-1], times[1:]): # option expiration event before each period events.append( { \"track\": track + \".opt\", \"time\": start, \"op\": \">\", \"quantity\": 1, \"unit\": track + \".swp\", } ) # payment event for the underlying swap events.extend( simple_swap_period(ccy, start, end, strike_rate, track + \".swp\") ) return timetable_from_dicts(events) simple_swap_period(ccy, start, end, fixed_rate, track='') Simple representation of a swap period, paying fixed, receiving floating rate. Parameters: ccy ( str ) \u2013 the currency of the swap. start ( float ) \u2013 the start of the period in years. end ( float ) \u2013 the end of the period in years. fixed_rate ( float ) \u2013 the fixed annual rate of the swap. track ( str , default: '' ) \u2013 an optional identifier for the contract. Source code in qablet_contracts\\rate\\swaption.py def simple_swap_period( ccy: str, start: float, end: float, fixed_rate: float, track: str = \"\" ) -> list: \"\"\"Simple representation of a swap period, paying fixed, receiving floating rate. Args: ccy: the currency of the swap. start: the start of the period in years. end: the end of the period in years. fixed_rate: the fixed annual rate of the swap. track: an optional identifier for the contract. \"\"\" return [ { \"track\": track, \"time\": start, \"op\": \"+\", \"quantity\": 1, \"unit\": ccy, }, { \"track\": track, \"time\": end, \"op\": \"+\", \"quantity\": -1 - fixed_rate * (end - start), \"unit\": ccy, }, ] swaption_timetable(ccy, times, strike_rate, track='') Create timetable for a vanilla swaption. Parameters: ccy ( str ) \u2013 the currency of the swap. times ( list [ float ] ) \u2013 the period times of the underlying swap, including the inception and maturity. strike_rate ( float ) \u2013 the strike rate of the swaption (in units, i.e. 0.02 means 200 bps). track ( str , default: '' ) \u2013 an optional identifier for the contract. Source code in qablet_contracts\\rate\\swaption.py def swaption_timetable( ccy: str, times: list[float], strike_rate: float, track: str = \"\" ) -> dict: \"\"\"Create timetable for a vanilla swaption. Args: ccy: the currency of the swap. times: the period times of the underlying swap, including the inception and maturity. strike_rate: the strike rate of the swaption (in units, i.e. 0.02 means 200 bps). track: an optional identifier for the contract. \"\"\" # option expiration event at beginning of the swap events = [ { \"track\": track + \".opt\", \"time\": times[0], \"op\": \">\", \"quantity\": 1, \"unit\": track + \".swp\", } ] # payment events for the underlying swap for start, end in zip(times[0:-1], times[1:]): events.extend( simple_swap_period(ccy, start, end, strike_rate, track + \".swp\") ) return timetable_from_dicts(events)","title":"Rates"},{"location":"examples/rate/#rates","text":"This module contains examples of creating timetables for rate contracts such as swaps and swaptions.","title":"Rates"},{"location":"examples/rate/#qablet_contracts.rate.swaption.bermuda_swaption_timetable","text":"Create timetable for a co-terminal bermuda swaption. Parameters: ccy ( str ) \u2013 the currency of the swap. times ( list [ float ] ) \u2013 the period times of the underlying swap, including the inception and maturity. strike_rate ( float ) \u2013 the strike rate of the swaption (in units, i.e. 0.02 means 200 bps). track ( str , default: '' ) \u2013 an optional identifier for the contract. Source code in qablet_contracts\\rate\\swaption.py def bermuda_swaption_timetable( ccy: str, times: list[float], strike_rate: float, track: str = \"\" ) -> dict: \"\"\"Create timetable for a co-terminal bermuda swaption. Args: ccy: the currency of the swap. times: the period times of the underlying swap, including the inception and maturity. strike_rate: the strike rate of the swaption (in units, i.e. 0.02 means 200 bps). track: an optional identifier for the contract. \"\"\" events = [] for start, end in zip(times[0:-1], times[1:]): # option expiration event before each period events.append( { \"track\": track + \".opt\", \"time\": start, \"op\": \">\", \"quantity\": 1, \"unit\": track + \".swp\", } ) # payment event for the underlying swap events.extend( simple_swap_period(ccy, start, end, strike_rate, track + \".swp\") ) return timetable_from_dicts(events)","title":"bermuda_swaption_timetable()"},{"location":"examples/rate/#qablet_contracts.rate.swaption.simple_swap_period","text":"Simple representation of a swap period, paying fixed, receiving floating rate. Parameters: ccy ( str ) \u2013 the currency of the swap. start ( float ) \u2013 the start of the period in years. end ( float ) \u2013 the end of the period in years. fixed_rate ( float ) \u2013 the fixed annual rate of the swap. track ( str , default: '' ) \u2013 an optional identifier for the contract. Source code in qablet_contracts\\rate\\swaption.py def simple_swap_period( ccy: str, start: float, end: float, fixed_rate: float, track: str = \"\" ) -> list: \"\"\"Simple representation of a swap period, paying fixed, receiving floating rate. Args: ccy: the currency of the swap. start: the start of the period in years. end: the end of the period in years. fixed_rate: the fixed annual rate of the swap. track: an optional identifier for the contract. \"\"\" return [ { \"track\": track, \"time\": start, \"op\": \"+\", \"quantity\": 1, \"unit\": ccy, }, { \"track\": track, \"time\": end, \"op\": \"+\", \"quantity\": -1 - fixed_rate * (end - start), \"unit\": ccy, }, ]","title":"simple_swap_period()"},{"location":"examples/rate/#qablet_contracts.rate.swaption.swaption_timetable","text":"Create timetable for a vanilla swaption. Parameters: ccy ( str ) \u2013 the currency of the swap. times ( list [ float ] ) \u2013 the period times of the underlying swap, including the inception and maturity. strike_rate ( float ) \u2013 the strike rate of the swaption (in units, i.e. 0.02 means 200 bps). track ( str , default: '' ) \u2013 an optional identifier for the contract. Source code in qablet_contracts\\rate\\swaption.py def swaption_timetable( ccy: str, times: list[float], strike_rate: float, track: str = \"\" ) -> dict: \"\"\"Create timetable for a vanilla swaption. Args: ccy: the currency of the swap. times: the period times of the underlying swap, including the inception and maturity. strike_rate: the strike rate of the swaption (in units, i.e. 0.02 means 200 bps). track: an optional identifier for the contract. \"\"\" # option expiration event at beginning of the swap events = [ { \"track\": track + \".opt\", \"time\": times[0], \"op\": \">\", \"quantity\": 1, \"unit\": track + \".swp\", } ] # payment events for the underlying swap for start, end in zip(times[0:-1], times[1:]): events.extend( simple_swap_period(ccy, start, end, strike_rate, track + \".swp\") ) return timetable_from_dicts(events)","title":"swaption_timetable()"},{"location":"specifications/batch/","text":"Batch To be documented in a future revision.","title":"Batch"},{"location":"specifications/batch/#batch","text":"To be documented in a future revision.","title":"Batch"},{"location":"specifications/expressions/","text":"Expressions To be documented in a future revision.","title":"Expressions"},{"location":"specifications/expressions/#expressions","text":"To be documented in a future revision.","title":"Expressions"},{"location":"specifications/operations/","text":"Operations The op column contains a string which can be + , > , < , or a condition Payment + in the ops column indicates that the contract holder will receive the payment specified by the quantity and the unit , and then continue to receive whatever else is further down in the timetable in the same track. Example: A bond paying 5 USD semi-annually and maturing in two years. track time op quantity unit 0.5 + 5 USD 1.0 + 5 USD 1.5 + 5 USD 2.0 + 105 USD Choice of contract holder > in the ops column indicates that the contract holder can choose from the following two options receive the payment specified by the quantity and the unit , and then terminate the contract. or, instead of that payment, receive whatever else is further down in the timetable in the same track. Example: An European Call Option with strike 2800, expiring in 1 year. track time op quantity unit 1.0 > 0.0 USD 1.0 + -2800.0 USD 1.0 + 1.0 SPX Choice of contract's counterparty < in the ops column indicates that the counterparty can choose from the following two options pay the holder the payment specified by the quantity and the unit , and then terminate the contract. or, instead of that payment, pay the holder whatever else is further down in the timetable in the same track. Example: A callable bond, paying 5 USD semi-annually, maturing in two years, and callable at the end of the first year. track time op quantity unit 0.5 + 5 USD 1.0 + 5 USD 1.0 < 100 USD 1.5 + 5 USD 2.0 + 105 USD Contingent Event Anything else in the op column is the string name of an expression. If the expression evaluates to true, the holder will receive the payment specified by the quantity and the unit , and then terminate the contract. If the expression evaluates to false, then instead of that payment, holder will receive whatever else is further down in the timetable in the same track. Example: knock-in or knock-out events in a barrier option. Snapper If the unit column contains a Snapper, i.e. a path dependent calculation to be performed at that time, then the op column is ignored.","title":"Operations"},{"location":"specifications/operations/#operations","text":"The op column contains a string which can be + , > , < , or a condition","title":"Operations"},{"location":"specifications/operations/#payment","text":"+ in the ops column indicates that the contract holder will receive the payment specified by the quantity and the unit , and then continue to receive whatever else is further down in the timetable in the same track. Example: A bond paying 5 USD semi-annually and maturing in two years. track time op quantity unit 0.5 + 5 USD 1.0 + 5 USD 1.5 + 5 USD 2.0 + 105 USD","title":"Payment"},{"location":"specifications/operations/#choice-of-contract-holder","text":"> in the ops column indicates that the contract holder can choose from the following two options receive the payment specified by the quantity and the unit , and then terminate the contract. or, instead of that payment, receive whatever else is further down in the timetable in the same track. Example: An European Call Option with strike 2800, expiring in 1 year. track time op quantity unit 1.0 > 0.0 USD 1.0 + -2800.0 USD 1.0 + 1.0 SPX","title":"Choice of contract holder"},{"location":"specifications/operations/#choice-of-contracts-counterparty","text":"< in the ops column indicates that the counterparty can choose from the following two options pay the holder the payment specified by the quantity and the unit , and then terminate the contract. or, instead of that payment, pay the holder whatever else is further down in the timetable in the same track. Example: A callable bond, paying 5 USD semi-annually, maturing in two years, and callable at the end of the first year. track time op quantity unit 0.5 + 5 USD 1.0 + 5 USD 1.0 < 100 USD 1.5 + 5 USD 2.0 + 105 USD","title":"Choice of contract's counterparty"},{"location":"specifications/operations/#contingent-event","text":"Anything else in the op column is the string name of an expression. If the expression evaluates to true, the holder will receive the payment specified by the quantity and the unit , and then terminate the contract. If the expression evaluates to false, then instead of that payment, holder will receive whatever else is further down in the timetable in the same track. Example: knock-in or knock-out events in a barrier option.","title":"Contingent Event"},{"location":"specifications/operations/#snapper","text":"If the unit column contains a Snapper, i.e. a path dependent calculation to be performed at that time, then the op column is ignored.","title":"Snapper"},{"location":"specifications/snapper/","text":"Snapper A Snapper represents a path dependent calculation , e.g. calculating returns in an equity cliquet. In the following timetable, the first event represents a snapper operation UPDATE . This operation stores its result in a snap . The second event represents a payment for the contract, which pays A , the value of the snap. track time op quantity unit NaN 0.5 UPDATE 0.0 None 0.0 3.0 + 1.0 A A snapper is defined in the dataset, with four parameters. type , which must be \"snapper\" inp , a list of inputs to the snap_fn. These can be assets, such as \"SPX\", whose value comes from the model. These can also be snaps, such as \"A\" or \"S_last\", which has been stored as a result of previous snapper operation. snap_fn , a python function that takes the inputs, and returns snap values. The length of expected inputs list must match the length of inp , while the length of the output list must match the length of out . out , the list of name of snap variables where the result is stored. e.g. # Define the function def accumulator_update_fn(inputs): [s, s_last, a] = inputs ret = s / s_last - 1.0 # ret = S / S_last - 1 ret = np.maximum(local_floor, ret) ret = np.minimum(local_cap, ret) return [a + ret, s] # [A, S_last] # Define the snapper \"UPDATE\": { \"type\": \"snapper\", \"inp\": [\"SPX\", \"S_last\", \"A\"], \"snap_fn\": accumulator_update_fn, \"out\": [\"A\", \"S_last\"], }, Note: The values of the inputs will be a float, or a 1-D numpy array (e.g. the value of that variable in each Monte-Carlo path, or each point of a Finite Difference grid axis). All numpy arrays will be of the same size, or of length 1. The values of the output of the snap_fn must also be a scalar, of size 1, or same size as the inputs. A snapper written using arithmetic operations like + , - , * , and numpy functions would satisfy these requirements.","title":"Snapper"},{"location":"specifications/snapper/#snapper","text":"A Snapper represents a path dependent calculation , e.g. calculating returns in an equity cliquet. In the following timetable, the first event represents a snapper operation UPDATE . This operation stores its result in a snap . The second event represents a payment for the contract, which pays A , the value of the snap. track time op quantity unit NaN 0.5 UPDATE 0.0 None 0.0 3.0 + 1.0 A A snapper is defined in the dataset, with four parameters. type , which must be \"snapper\" inp , a list of inputs to the snap_fn. These can be assets, such as \"SPX\", whose value comes from the model. These can also be snaps, such as \"A\" or \"S_last\", which has been stored as a result of previous snapper operation. snap_fn , a python function that takes the inputs, and returns snap values. The length of expected inputs list must match the length of inp , while the length of the output list must match the length of out . out , the list of name of snap variables where the result is stored. e.g. # Define the function def accumulator_update_fn(inputs): [s, s_last, a] = inputs ret = s / s_last - 1.0 # ret = S / S_last - 1 ret = np.maximum(local_floor, ret) ret = np.minimum(local_cap, ret) return [a + ret, s] # [A, S_last] # Define the snapper \"UPDATE\": { \"type\": \"snapper\", \"inp\": [\"SPX\", \"S_last\", \"A\"], \"snap_fn\": accumulator_update_fn, \"out\": [\"A\", \"S_last\"], }, Note: The values of the inputs will be a float, or a 1-D numpy array (e.g. the value of that variable in each Monte-Carlo path, or each point of a Finite Difference grid axis). All numpy arrays will be of the same size, or of length 1. The values of the output of the snap_fn must also be a scalar, of size 1, or same size as the inputs. A snapper written using arithmetic operations like + , - , * , and numpy functions would satisfy these requirements.","title":"Snapper"},{"location":"specifications/timetable/","text":"Timetable A contract is described by a list of events. An event has five properties: track time op quantity unit Here is an example of an equity call option contract on SPX, with strike 2800 and one year expiration. It is described using three events. track time op quantity unit 1.0 > 0.0 USD 1.0 + -2800.0 USD 1.0 + 1.0 SPX Track A string identifier for the contract, a leg of the contract, or a state of the contract. Time The time of an event in years (float) from the valuation date. Op A string which can be + , > , < , or a condition. See more in the Operations section. Quantity The quantity being paid (float). Unit A string that represents what is being paid. It can be a currency like USD , EUR , or a stock like SPX , AAPL , etc. See the Units section for all possible variants. How to create a timetable The timetable is a dictionary with two components. events, the sequence of events stored as a pyarrow recordbatch expresions, a dictionary defining any snappers, batches, or expressions used in the timetable A simple timetable can be created using this method, from a list of dicts. timetable_from_dicts(events) Create timetable from a list of dicts. Parameters: events ( list [ dict ] ) \u2013 a list of dicts with the following fields: track: string time: float op: string quantity: float unit: string Returns: dict \u2013 a timetable dictionary with the following fields: events: a pyarrow record batch expressions: a dict for expressions, batches, and snappers Source code in qablet_contracts\\timetable.py def timetable_from_dicts(events: list[dict]) -> dict: \"\"\"Create timetable from a list of dicts. Args: events: a list of dicts with the following fields: - track: string - time: float - op: string - quantity: float - unit: string Returns: a timetable dictionary with the following fields: - events: a pyarrow record batch - expressions: a dict for expressions, batches, and snappers \"\"\" return { \"events\": pa.RecordBatch.from_pylist(events, schema=EVENT_SCHEMA), \"expressions\": {}, } Example Define a contract that pays 100 USD after 1 year. from api import timetable_from_dicts events = [ { \"track\": \"\", \"time\": 1.0, \"op\": \"+\", \"quantity\": 100.0, \"unit\": \"USD\" }, ] timetable = timetable_from_dicts(events) print(timetable[\"events\"].to_pandas()) Output: track time op quantity unit 0 1.0 + 100.0 USD","title":"Timetable"},{"location":"specifications/timetable/#timetable","text":"A contract is described by a list of events. An event has five properties: track time op quantity unit Here is an example of an equity call option contract on SPX, with strike 2800 and one year expiration. It is described using three events. track time op quantity unit 1.0 > 0.0 USD 1.0 + -2800.0 USD 1.0 + 1.0 SPX","title":"Timetable"},{"location":"specifications/timetable/#track","text":"A string identifier for the contract, a leg of the contract, or a state of the contract.","title":"Track"},{"location":"specifications/timetable/#time","text":"The time of an event in years (float) from the valuation date.","title":"Time"},{"location":"specifications/timetable/#op","text":"A string which can be + , > , < , or a condition. See more in the Operations section.","title":"Op"},{"location":"specifications/timetable/#quantity","text":"The quantity being paid (float).","title":"Quantity"},{"location":"specifications/timetable/#unit","text":"A string that represents what is being paid. It can be a currency like USD , EUR , or a stock like SPX , AAPL , etc. See the Units section for all possible variants.","title":"Unit"},{"location":"specifications/timetable/#how-to-create-a-timetable","text":"The timetable is a dictionary with two components. events, the sequence of events stored as a pyarrow recordbatch expresions, a dictionary defining any snappers, batches, or expressions used in the timetable A simple timetable can be created using this method, from a list of dicts.","title":"How to create a timetable"},{"location":"specifications/timetable/#qablet_contracts.timetable.timetable_from_dicts","text":"Create timetable from a list of dicts. Parameters: events ( list [ dict ] ) \u2013 a list of dicts with the following fields: track: string time: float op: string quantity: float unit: string Returns: dict \u2013 a timetable dictionary with the following fields: events: a pyarrow record batch expressions: a dict for expressions, batches, and snappers Source code in qablet_contracts\\timetable.py def timetable_from_dicts(events: list[dict]) -> dict: \"\"\"Create timetable from a list of dicts. Args: events: a list of dicts with the following fields: - track: string - time: float - op: string - quantity: float - unit: string Returns: a timetable dictionary with the following fields: - events: a pyarrow record batch - expressions: a dict for expressions, batches, and snappers \"\"\" return { \"events\": pa.RecordBatch.from_pylist(events, schema=EVENT_SCHEMA), \"expressions\": {}, }","title":"timetable_from_dicts()"},{"location":"specifications/timetable/#example","text":"Define a contract that pays 100 USD after 1 year. from api import timetable_from_dicts events = [ { \"track\": \"\", \"time\": 1.0, \"op\": \"+\", \"quantity\": 100.0, \"unit\": \"USD\" }, ] timetable = timetable_from_dicts(events) print(timetable[\"events\"].to_pandas()) Output: track time op quantity unit 0 1.0 + 100.0 USD","title":"Example"},{"location":"specifications/units/","text":"Unit A string representing what is being paid. It can be a a currency like USD , EUR a stock, or a commodity, like AAPL , CL a Track, e.g. the fixed leg of a swap an Expression, e.g. a libor fixing, a barrier, or a digital. a Batch event, e.g. issuers option to deliver one of many bonds. See more in the Batch section. a Snap, i.e. a path dependent quantity, e.g. an accumulator cliquet. See more in the Snapper section. It can also represent an action, such as a Snapper, e.g update an accumulator from the current return.","title":"Unit"},{"location":"specifications/units/#unit","text":"A string representing what is being paid. It can be a a currency like USD , EUR a stock, or a commodity, like AAPL , CL a Track, e.g. the fixed leg of a swap an Expression, e.g. a libor fixing, a barrier, or a digital. a Batch event, e.g. issuers option to deliver one of many bonds. See more in the Batch section. a Snap, i.e. a path dependent quantity, e.g. an accumulator cliquet. See more in the Snapper section. It can also represent an action, such as a Snapper, e.g update an accumulator from the current return.","title":"Unit"}]}